package com.jtdev.authhooker.util;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;

/**
 * Utility class for PKCE (Proof Key for Code Exchange) operations
 * 
 * PKCE is an OAuth 2.0 extension that prevents authorization code interception attacks.
 * It uses a dynamically generated code verifier and challenge.
 */
public final class PkceUtil {
    
    private static final SecureRandom SECURE_RANDOM = new SecureRandom();
    private static final int CODE_VERIFIER_LENGTH = 128; // Maximum allowed length
    
    private PkceUtil() {
        throw new UnsupportedOperationException("Utility class cannot be instantiated");
    }
    
    /**
     * Generate a PKCE code verifier
     * 
     * According to RFC 7636:
     * - code_verifier = high-entropy cryptographic random STRING using the
     *   unreserved characters [A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~"
     * - Minimum length of 43 characters and maximum length of 128 characters
     * 
     * @return A cryptographically random 128-character base64url-encoded string
     */
    public static String generateCodeVerifier() {
        // Generate 96 random bytes (will produce 128 chars when base64url-encoded)
        byte[] bytes = new byte[96];
        SECURE_RANDOM.nextBytes(bytes);
        
        // Base64url encode (no padding, URL-safe)
        return Base64.getUrlEncoder()
                .withoutPadding()
                .encodeToString(bytes);
    }
    
    /**
     * Generate a PKCE code challenge from a code verifier
     * 
     * According to RFC 7636:
     * - code_challenge = BASE64URL(SHA256(ASCII(code_verifier)))
     * - Uses S256 method (SHA-256 hash)
     * 
     * @param codeVerifier The code verifier generated by generateCodeVerifier()
     * @return The SHA-256 hash of the verifier, base64url-encoded
     * @throws IllegalArgumentException if code verifier is null or empty
     */
    public static String generateCodeChallenge(String codeVerifier) {
        if (codeVerifier == null || codeVerifier.isBlank()) {
            throw new IllegalArgumentException("Code verifier cannot be null or empty");
        }
        
        try {
            // SHA-256 hash of the code verifier
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(codeVerifier.getBytes(StandardCharsets.US_ASCII));
            
            // Base64url encode (no padding, URL-safe)
            return Base64.getUrlEncoder()
                    .withoutPadding()
                    .encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            // SHA-256 should always be available
            throw new RuntimeException("SHA-256 algorithm not available", e);
        }
    }
    
    /**
     * Verify that a code verifier matches a code challenge
     * 
     * This is useful for testing and validation purposes.
     * 
     * @param codeVerifier The original code verifier
     * @param codeChallenge The code challenge to verify against
     * @return true if the verifier matches the challenge, false otherwise
     */
    public static boolean verifyCodeChallenge(String codeVerifier, String codeChallenge) {
        if (codeVerifier == null || codeChallenge == null) {
            return false;
        }
        
        String computedChallenge = generateCodeChallenge(codeVerifier);
        return computedChallenge.equals(codeChallenge);
    }
}
